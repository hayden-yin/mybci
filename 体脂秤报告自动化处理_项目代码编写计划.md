# 程序项目代码编写计划与跨平台指南  
---

## 1 项目背景与目标  

本项目旨在通过 **PaddleOCR** 和 **Label Studio** 实现自动化的报告数据提取与处理。  

**核心目标：**  
* 第一次运行时，利用 Label Studio 进行 ML 辅助标注，生成一份结构化配置文件 (`config_ocr.json`)。  
* 后续日常运行时，程序将直接利用该配置文件来指导 OCR 识别特定区域并提取数据。  

**输出格式：**  
- 提取的结构化数据最终以 CSV 或 Excel 格式输出。  

---

## 2 开发环境与工具（修订）  

| 组件 / 类别 | 版本或标识 | 功能说明 | 部署方式与备注 |
|--------------|-------------|-----------|----------------|
| 操作系统 | Windows / Linux | 项目运行的基础平台 | 本地开发机或服务器均可 |
| Python 环境 | Conda 环境 `mybci` | 统一管理依赖，确保与 PaddlePaddle 兼容 | `conda create -n mybci python=3.10` |
| GPU / CUDA | CUDA 12.9 + NVIDIA RTX 2080 | 为 PaddlePaddle GPU 版提供加速支持 | 需预先安装 NVIDIA 驱动及 CUDA Toolkit 12.9 |
| PaddlePaddle | GPU 版（兼容 CUDA 12.9） | 底层深度学习框架，支撑 OCR 模型推理 | `pip install paddlepaddle-gpu` |
| PaddleOCR / PP-Structure | ≥ 2.7（最新稳定版） | 实现表格检测、文本识别 | `pip install "paddleocr>=2.7"` |
| Label Studio（前端） | heartexlabs/label-studio | Web 界面用于人工标注与 ML 辅助校正 | `docker run -p 8080:8080 ...` 启动 |
| ML Backend 服务 | label-studio-ml, fastapi | 接收 Label Studio 请求，调用 PaddleOCR 处理 | 在 mybci 环境中运行 `python ml_backend/server.py` |
| Web 后端框架 | FastAPI, Uvicorn, WebSockets | (新增) 提供 API 接口和 Web 界面服务 | `python run_web_app.py` |
| Web 前端框架 | HTML + TailwindCSS + Alpine.js | (新增) 构建轻量级、响应式前端 UI | FastAPI 提供静态文件服务 |
| 数据处理库 | pandas, openpyxl, lxml | 支持配置解析、Excel/CSV 输出等 | 统一安装于 mybci 环境中 |

*检查结果
    **从结果来看，你的 (mybci) 环境已经完全准备好了：
      -PaddlePaddle 3.2 + CUDA 支持 ✅
      -PaddleOCR + PPStructureV3 ✅
      -FastAPI / Uvicorn / WebSocket ✅
      -数据处理库（Pandas / openpyxl / lxml）✅
      -路径管理 & dotenv ✅
      -Pydantic Settings ✅
    **在 Pydantic 2.x 版本之后：BaseSettings 已经不再直接包含在 pydantic 包里。它被移到了 pydantic-settings 包中。如果你的代码里直接 from pydantic import BaseSettings 会报错。
        -正确的做法是安装 pydantic-settings，然后导入：from pydantic_settings import BaseSettings
    **PPStructure 已被替换为 PPStructureV3 → 导入时使用 from paddleocr import PPStructureV3

## 3 代码结构与功能模块（修订）  

以下是项目的核心目录和文件结构，集成了 Web 应用并分离了配置与数据：

mybci/
├── config/                            # (修订) 存放所有类型的 OCR 配置文件
│   └── config_ocr_bci.json            # BCI 报告配置
│   └── config_ocr_blood.json          # (示例) 其他报告配置
│
├── input/                             # (修订) 扁平化的图片上传目录
│   └── *.jpg
│
├── output/                            # (修订) 扁平化的结果输出目录
│   └── *.csv / *.xlsx
│
├── src/                               # (新增) 核心 Python 源代码目录
│   └── mybci/                         # (新增) 可安装的 Python 包
│       ├── __init__.py
│       │
│       ├── ocr_processing/
│       │   ├── __init__.py
│       │   ├── ppstructure_engine.py  # 底层 PaddleOCR 封装
│       │   └── ocr_executor.py        # 核心逻辑 (被 Web 和 ML 共同调用)
│       │
│       ├── ml_backend/
│       │   ├── __init__.py
│       │   ├── model.py
│       │   ├── server.py              # ML 后端的 FastAPI 入口
│       │   └── ocr_adapter.py         # (修订) 调用 ocr_executor 并转换格式
│       │
│       ├── webapp/
│       │   ├── __init__.py
│       │   ├── app.py                 # (修订) Web App 的 FastAPI 入口
│       │   ├── static/
│       │   │   ├── js/app.js
│       │   │   └── css/style.css
│       │   └── templates/
│       │       └── index.html
│       │
│       ├── utils/
│       │   ├── __init__.py
│       │   ├── json_handler.py
│       │   ├── csv_handler.py
│       │   └── convert_ls_to_config.py
│       │
│       └── core/                      # (推荐新增) 存放应用全局配置
│           ├── __init__.py
│           └── settings.py            # (例如 Pydantic Settings) 定义配置/输入/输出目录路径
│
├── run_web_app.py                     # (保留) 日常 Web 应用启动脚本
├── run_ml_backend.py                  # (推荐新增) 启动 ML 后端服务的脚本
├── pyproject.toml                     # (新增) 项目配置文件 (用于 pip install -e .)
└── requirements.txt                   # 依赖文件


## 关键文件与目录说明（修订版）

* config/: (去耦合)
  * 移除了 bci 子目录
  * 现在存放所有类型的报告配置（例如 config_ocr_bci.json）
  * Web APP 将通过参数（如 config_name=bci）来决定加载哪一个

* input/ 和 output/: (去耦合)
  * 移除了 bci 子目录，保持扁平化
  * input/ 作为所有文件的统一上传入口
  * output/ 存放所有导出的结果，文件名应动态生成（例如 bci_report_2025-11-01.csv）

* src/mybci/: (包结构)
  * 所有 Python 源代码现在都位于此包内
  * 安装方法：在项目根目录 mybci/ 下运行 pip install -e .
  * 这使得所有模块都可以使用绝对路径（如 from mybci.ocr_processing import ...）进行导入，彻底解决 sys.path 或相对导入问题。

* src/mybci/ocr_processing/ocr_executor.py: (逻辑统一)
  * 这是唯一封装了"加载配置 -> 调用引擎 -> 结构化数据"的核心逻辑模块
  * 它将被 webapp/app.py（用于日常处理）和 ml_backend/ocr_adapter.py（用于预标注）共同调用

* src/mybci/ml_backend/ocr_adapter.py: (逻辑统一)
  * 重大变更：此模块不再调用底层的 ppstructure_engine.py
  * 它将 import 并调用 ocr_processing.ocr_executor.process_image() 函数获取 Python 字典结果，然后仅负责将其转换为 Label Studio 所需的 JSON 格式。这保证了预标注和实际处理的逻辑 100% 一致。

* src/mybci/webapp/app.py:
  * 定义 FastAPI 应用 app 对象
  * (去耦合) API 接口（如 /process）需要修改，以接收一个项目类型参数（例如 POST /process?config_name=bci），以便 ocr_executor 知道要加载 config/config_ocr_bci.json。

* run_web_app.py: (保留的启动脚本)
  * 此脚本位于根目录，其内容非常简单，用于启动 src/ 包内的 Web 应用
  * 示例内容：
        import uvicorn

        # 假设您在 src/mybci/core/settings.py 中定义了 HOST 和 PORT
        # from mybci.core.settings import WEB_HOST, WEB_PORT 

        if __name__ == "__main__":
            # 必须先 'pip install -e .' 才能使 'mybci.webapp.app' 可被找到
            uvicorn.run(
                "mybci.webapp.app:app", 
                host="0.0.0.0", 
                port=8000, 
                reload=True
            )

* run_ml_backend.py: (推荐新增)
  * 与 run_web_app.py 类似，用于启动 ML 后端服务
  * 示例内容：uvicorn.run("mybci.ml_backend.server:app", ...)

* pyproject.toml: (包结构)
  * 用于声明 src/ 目录是一个名为 mybci 的包
  * 这是 pip install -e . 工作的基础

## 4 模块功能设计（修订）  

### 4.1 ML 后端服务模块 (`ml_backend/`)
* 负责在配置阶段，为 Label Studio 提供 PaddleOCR 预标注服务。
- `model.py`：ML后端入口,加载 Paddle 模型,实现 predict()方法。。
- `ocr_adapter.py`：调用 src.mybci.ocr_processing.ocr_executor.process_image() 获取结果。 转换为 Label Studio 格式
- `server.py`：启动 FastAPI服务,运行model.py.

### 4.2 OCR 核心处理模块 (`ocr_processing/`)
* `ppstructure_engine.py`：封装对 PaddleOCR的底层调用,提供原子化 识别功能。
* `ocr_executor.py`：* 负责根据传入的 config_name（例如 "bci"）加载对应的 config/config_ocr_{config_name}.json 文件。提供一个 process_image 函数供 webapp 和 ml_backend 调用

### 4.3 工具函数 (`utils/`)
* `json_handler.py`：安全读写与验证。
* `csv_handler.py`：负责接收 ocr_executor.py 返回的字典数据列 表,并根据 config_ocr.json 中定义的 output_column 动态生成CSV 或 Excel文件。
* `convert_ls_to_config.py`：核心转换脚本。 读取 Label Studio 导出的 JSON,并生成 config/config_ocr_bci.json。

### 4.4 Web 应用模块 (`webapp/`)
* 后端：后端(FastAPI):提供 API接口(图片上传、任务调度),并提供 WebSocket 接口用于实时日志推送。
* 前端：前端(HTML/Tailwind/Alpine.js):构建轻量级、无需编译的响应式界 面。
- app.py: (修订)
  * API 接口需要修改，以支持 config_name 参数
  * 实现多配置/多项目类型的处理
- `templates/index.html`：项目唯一的HTML 界面,包含7个功能区块 (见5.1)。
- `static/js/app.js`：(Alpine.js) 负责所有前端交互逻辑(AJAX调用、 WebSocket 监听、UI状态管理)。

---

## 5 Web 架构与工作流（新增）  

### 5.1 前端 UI 功能区块  
区块                                      功能说明
1.待分析图片 目录 [cite: 113]            (可选)显示 input/ 目录下的现有图片列表 [cite: 113]
2. 待分析图片 上传框 [cite: 113]         "核心功能:允许用户拖拽或点击上传图片,图片将保存到 input/. [cite: 113]"
3.处理区块 [cite: 113]                  包含“开始处理”按钮，点击时将所选 config_name 传递给 /process API。 [cite: 113]
3.1 处理区块中的配置选择                  一个下拉菜单或按钮组，用于选择要使用的配置 (例如 BCI, Blood Test)，选择结果将作为 config_name 传递给 /process API。
4.结果检查区 块 [cite: 115]             "三栏布局:左侧为处理完的图片列表,中间为原图, 识别结果的 JSON 预览和格式化表格预览。 [cite: 115]"
5.生成按钮 [cite: 115]                  "点击后调用API,后端生成 output/results_{config_name}.csv(或xlsx)并提供下 载。 [cite: 115]"
6. Label Studio 按钮 [cite: 115]        "一个简单的HTML链接(<a>标签),跳转到 http//:localhost:8080 (Label Studio 实例)。 [cite: 115]"
7. 清理按钮 [cite: 115],"调用API        清空 input//和 output/目录中的文件。 [cite: 115]"

---

### 5.2 后端 API 设计 (FastAPI)
路径                                      |         方法                 |   功能
/ [cite: 119]                             |      GET [cite: 119]        | 返回 index.html 主页 [cite: 119]
/upload [cite: 119]                       |      POST [cite: 119]       | "处理文件上传,保存到input/。 [cite: 119]"
/process [cite: 119]                      |      POST [cite: 119]       | 触发对 input/ 中所有图片的批量 OCR 处理，使用由 {config_name} 指定的配置文件 (例如 POST /process/bci)。 [cite: 119]
/ws [cite: 119]                           |      WebSocket [cite: 119]  | 实时推送/process 过程中的日志和进度。 [cite: 119]
/results [cite: 119]                      |      GET [cite: 119]        | (可选)  列出 input/中已处理的图片及其结果状 态。 [cite: 119]
/result/{filename} [cite: 119]            |      GET [cite: 119]        | "获取指定图片的原图路径和识别结果JSON,用于“结 果检查区块”。 [cite: 119]"
/generate [cite: 119]                     |      POST [cite: 119]       | "触发 utils/csv_handler.py 生成最终报告,并返回文件 下载链接。 [cite: 119]"
/clear [cite: 119]                        |      POST [cite: 119]       | 清理 input/ 和 output/目录 [cite: 119]

---

### 5.3 系统工作流  

**一次性配置流程：**
Label Studio (ML)          | [cite: 124]
| (localhost:8080)         | [cite: 125]
| 1. 导出 Is_export.json [cite: 126]
utils/convert_ls.py        | [cite: 127]
| 2.运行转换脚本 [cite: 128]
config/config_ocr_bci.json (配置实例) | (唯一配置) [cite: 129]

**日常使用流程：**
| webapp (FastAPI + HTML) | [cite: 131]
| (localhost:8000) [cite: 132]
3.用户上传图片 4. 点击“处理” [cite: 133]
(调用/upload) | (调用/process) [cite: 134]
| input/ [cite: 135]
| | ocr_executor | [cite: 136]
|(存放图片) [cite: 137]
| [cite: 138]
| (读取 config) | [cite: 139]
| webapp (前端显示结果)| [cite: 140]
| 6.点击“生成” [cite: 141]
| output/{dynamic_file_name}.csv | [cite: 142]
| 5.返回结果 [cite: 143]

## 6 开发阶段（修订）  

| 阶段 | 时间 | 内容 |
|------|------|------|
| 阶段 1 | 0.5 周 | 环境搭建与依赖安装 |
| 阶段 2 | 1 周 | ML 辅助标注流程 |
| 阶段 3 | 0.5 周 | 转换脚本开发 |
| 阶段 4 | 0.5 周 | OCR 核心逻辑重构 |
| 阶段 5 | 1.5 周 | Web 后端与 API 开发 |
| 阶段 6 | 1 周 | Web 前端开发 |
| 阶段 7 | 1 周 | 集成测试与优化 |

---

# 跨平台开发与部署指南（Python + Node.js + Playwright）

本指南面向需要同时在 **Windows 与 Linux** 环境下开发、测试、部署的团队，尤其是使用 **Python / Node.js / Playwright** 的项目。目标是提供一份兼顾 **规范性、可操作性、可维护性** 的唯一文档。

---

## 1. 语言层面的可移植性

### 1.1 Python
- 使用 **FastAPI** 或 **Flask** 构建 API Server，跨平台无差别。  
- 使用虚拟环境（`venv` / `conda`）避免依赖冲突。  
- **避免依赖系统默认编码或路径写死**。  
- **避免假设脚本可直接执行**：统一用 `python script.py` 调用，而不是依赖 Linux 的 `#!/usr/bin/env python3`。  
- 锁定依赖：推荐 `pip-tools` 生成 `requirements.txt`。  

### 1.2 Node.js
- 使用 **Express.js** 或 **Koa** 构建 API Server。  
- 使用 `nvm`（Linux/macOS）或 `nvm-windows` 管理 Node.js 版本。  
- 避免硬编码路径和依赖系统默认编码。  
- 锁定依赖：`package-lock.json` 或 `yarn.lock`，生产/CI 环境推荐 `npm ci`。  

---

## 2. 文件与路径处理
- 永远不要写死路径。  
- Python：优先用 `pathlib`；老项目可用 `os.path.join`。  
- Node.js：使用 `path` 模块，`os.homedir()` 获取用户目录。  
- 临时文件使用标准库 API（Python: `tempfile`，Node.js: `os.tmpdir()`）。  
- 路径与大小写需注意：Windows 不敏感，Linux 敏感。  
- 文件读写必须明确指定 UTF-8 编码。  

---

## 3. 环境变量与配置管理
- 使用 `.env` 文件存放配置，加入 `.gitignore`。  
- Python 使用 `python-dotenv` 或 `pydantic.BaseSettings`，Node.js 使用 `dotenv`。  
- 提供默认值，避免缺失报错。  
- 对配置进行验证，确保类型和范围正确。  

---

## 4. Playwright 跨平台注意事项
- 安装浏览器依赖：Python `playwright install`，Node.js `npx playwright install`。  
- 不硬编码浏览器路径，由 Playwright 管理。  
- 注意字体与渲染差异，截图/PDF 输出需统一字体。  
- CI/CD 和服务器环境建议使用无头模式。  
- 用户数据目录（持久化登录/缓存）需跨平台路径生成。  

---

## 5. API Server 部署方式
- **方法 A：源码 + 本地环境**  
  - Ubuntu / Windows 分别安装依赖，保持代码一致。  

- **方法 B：容器化（推荐）**  
  - 使用 Docker 打包环境，保证依赖和运行结果一致。  

- **方法 C：独立可执行文件**  
  - Python: PyInstaller 或 Nuitka，打包解释器、依赖、浏览器驱动。  
  - Node.js: Pkg 或 Nexe，将 Node.js 运行时和 node_modules 打包。  
  - 优点：目标环境无需配置。  
  - 挑战：包体积大，需处理资源路径。  

- **方法 D：系统服务（新增）**  
  - Linux: systemd service 文件，支持开机自启与自动重启。  
  - Windows: Service Manager / NSSM 注册服务。  

---

## 6. 跨平台坑点与解决方案

### 6.1 编码问题
- Windows 默认 GBK，Linux 默认 UTF-8。  
- 文件读写必须显式指定 UTF-8。

### 6.2 换行符
- Windows: CRLF，Linux: LF。  
- Git 自动处理换行符：Windows `core.autocrlf true`，Linux/macOS `core.autocrlf input`。  

### 6.3 字体 / 渲染差异
- 截图或 PDF 输出在不同系统可能有微小差异。  
- 建议使用统一字体或仅提取文本/数据。

### 6.4 执行外部命令
- Python: `subprocess.run([...])`，Node.js: `child_process.spawn / execFile`。  
- 避免平台特有命令（如 `dir` vs `ls`）。

### 6.5 文件权限
- Linux 需要 `chmod +x` 才能执行脚本，Windows 没有此限制。  

### 6.6 时间与时区
- 日志和数据库时间统一使用 UTC，展示时再转换本地时区。  

### 6.7 临时文件与缓存
- 避免写死 `/tmp` 或 `%TEMP%`，使用标准库 API。  

### 6.8 文件系统大小写敏感性
- Windows 文件系统不敏感，Linux 敏感。  
- 命名文件、生成缓存 key 时避免大小写冲突。  

### 6.9 网络与防火墙
- API Server 监听需用 `0.0.0.0`，否则外部无法访问。  
- 系统防火墙需开放对应端口（如 8000）。  

### 6.10 Playwright 用户数据目录
- 通过 `user_data_dir` 持久化浏览器状态。  
- 路径生成需跨平台。  

### 6.11 信号与进程管理（新增）
- 优雅关闭进程，清理资源（数据库、文件句柄、临时目录）。  
- Linux 支持 SIGINT / SIGTERM，Windows 信号支持有限，可使用 psutil / process-exit。  

### 6.12 性能与资源管理（新增）
- 文件监控使用跨平台库（watchdog / chokidar）。  
- 避免频繁创建子进程。  
- 监控内存和 CPU 使用，便于排查跨平台差异。  

---

## 7. 依赖管理
- Python: requirements.txt + pip-tools。  
- Node.js: package-lock.json + npm ci。  
- 确保跨平台依赖一致。  

---

## 8. CI/CD 与跨平台测试
- 双平台测试矩阵：Ubuntu / Windows。  
- 平台条件测试标记：pytest.mark.skipif / jest testEnvironment。  
- 打印关键版本信息（Python / Node / Playwright）。  
- 建议使用 Dev Containers 或 Codespaces 确保开发环境一致。  

---

## 9. 常见陷阱与避免策略（新增）
- 避免依赖系统默认编码：读写文件明确指定 UTF-8。  
- 避免路径写死：使用 path.join / pathlib。  
- 避免假设脚本可直接执行：统一用 `python script.py` / `node app.js`。  
- 避免文件名大小写不一致造成的问题。  

---

## 10. 健康检查与监控
- 暴露 `/health` 接口返回服务状态、时间戳、平台和版本信息。  
- 日志结构化输出 JSON，包括时间、平台、版本、上下文 ID。  
- 推荐配合 Prometheus / Grafana 监控。  

---

## 11. 错误处理与安全考虑
- 文件路径校验，防止目录遍历。  
- 临时文件安全：使用安全 API。  
- 日志中屏蔽敏感环境变量。  
- API 层面增加速率限制、鉴权。  

---

## 12. 部署与回滚策略
- 版本标记包含平台信息：`v1.0.0-ubuntu` / `v1.0.0-windows`。  
- 支持单平台独立回滚。  
- 推荐蓝绿部署或滚动更新。  

---

## 13. 文档与团队协作
- 环境搭建指南（Ubuntu / Windows 分别说明）。  
- 问题排查手册，包含常见跨平台坑点。  
- 代码审查清单，包括跨平台兼容性检查。  

---

## 14. CI/CD 检查清单
- [ ] Linux + Windows 双平台构建与测试。  
- [ ] Playwright 浏览器依赖已安装。  
- [ ] 单元测试与端到端测试通过。  
- [ ] 健康检查接口正常。  
- [ ] 日志无敏感信息。  
- [ ] 部署验证脚本通过。  
- [ ] 回滚策略已验证。  
- [ ] 环境变量完整且合法。  
- [ ] 文件权限符合运行要求。  
- [ ] 路径与大小写处理正确。  
- [ ] user_data_dir 持久化路径跨平台生成。  

---

## 总结
本指南覆盖 **语言层、依赖、路径、性能、部署、测试、日志、安全、运维** 等完整流程。  
重点强化 **结构化日志、健康检查、配置验证、回滚策略**，确保跨平台开发和生产环境运行的稳定性与可维护性。